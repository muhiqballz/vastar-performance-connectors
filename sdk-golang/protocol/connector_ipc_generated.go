// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package Ipc

import (
	flatbuffers "github.com/google/flatbuffers/go"
	"strconv"
)

/// Error classification untuk retry policy
type ErrorClass int8

const (
	/// Success - no error
	ErrorClassSuccess        ErrorClass = 0
	/// Transient error - safe to retry
	ErrorClassTransient      ErrorClass = 1
	/// Permanent error - do not retry
	ErrorClassPermanent      ErrorClass = 2
	/// Rate limited - retry with backoff
	ErrorClassRateLimited    ErrorClass = 3
	/// Timeout - may retry with caution
	ErrorClassTimeout        ErrorClass = 4
	/// Invalid request - do not retry
	ErrorClassInvalidRequest ErrorClass = 5
)

var EnumNamesErrorClass = map[ErrorClass]string{
	ErrorClassSuccess:        "Success",
	ErrorClassTransient:      "Transient",
	ErrorClassPermanent:      "Permanent",
	ErrorClassRateLimited:    "RateLimited",
	ErrorClassTimeout:        "Timeout",
	ErrorClassInvalidRequest: "InvalidRequest",
}

var EnumValuesErrorClass = map[string]ErrorClass{
	"Success":        ErrorClassSuccess,
	"Transient":      ErrorClassTransient,
	"Permanent":      ErrorClassPermanent,
	"RateLimited":    ErrorClassRateLimited,
	"Timeout":        ErrorClassTimeout,
	"InvalidRequest": ErrorClassInvalidRequest,
}

func (v ErrorClass) String() string {
	if s, ok := EnumNamesErrorClass[v]; ok {
		return s
	}
	return "ErrorClass(" + strconv.FormatInt(int64(v), 10) + ")"
}

/// Message type untuk frame header
type MessageType int8

const (
	/// Execute operation request
	MessageTypeExecuteRequest  MessageType = 0
	/// Execute operation response
	MessageTypeExecuteResponse MessageType = 1
	/// Health check ping
	MessageTypeHealthCheck     MessageType = 2
	/// Health check response
	MessageTypeHealthResponse  MessageType = 3
	/// Credit update (backpressure)
	MessageTypeCreditUpdate    MessageType = 4
)

var EnumNamesMessageType = map[MessageType]string{
	MessageTypeExecuteRequest:  "ExecuteRequest",
	MessageTypeExecuteResponse: "ExecuteResponse",
	MessageTypeHealthCheck:     "HealthCheck",
	MessageTypeHealthResponse:  "HealthResponse",
	MessageTypeCreditUpdate:    "CreditUpdate",
}

var EnumValuesMessageType = map[string]MessageType{
	"ExecuteRequest":  MessageTypeExecuteRequest,
	"ExecuteResponse": MessageTypeExecuteResponse,
	"HealthCheck":     MessageTypeHealthCheck,
	"HealthResponse":  MessageTypeHealthResponse,
	"CreditUpdate":    MessageTypeCreditUpdate,
}

func (v MessageType) String() string {
	if s, ok := EnumNamesMessageType[v]; ok {
		return s
	}
	return "MessageType(" + strconv.FormatInt(int64(v), 10) + ")"
}

/// Request untuk eksekusi operasi connector
type ExecuteRequest struct {
	_tab flatbuffers.Table
}

func GetRootAsExecuteRequest(buf []byte, offset flatbuffers.UOffsetT) *ExecuteRequest {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ExecuteRequest{}
	x.Init(buf, n+offset)
	return x
}

func FinishExecuteRequestBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsExecuteRequest(buf []byte, offset flatbuffers.UOffsetT) *ExecuteRequest {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ExecuteRequest{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedExecuteRequestBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *ExecuteRequest) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ExecuteRequest) Table() flatbuffers.Table {
	return rcv._tab
}

/// Unique request ID untuk correlation
func (rcv *ExecuteRequest) RequestId() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

/// Unique request ID untuk correlation
func (rcv *ExecuteRequest) MutateRequestId(n uint64) bool {
	return rcv._tab.MutateUint64Slot(4, n)
}

/// Tenant ID (for multi-tenancy)
func (rcv *ExecuteRequest) TenantId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Tenant ID (for multi-tenancy)
/// Workspace ID (optional)
func (rcv *ExecuteRequest) WorkspaceId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Workspace ID (optional)
/// Trace ID untuk distributed tracing
func (rcv *ExecuteRequest) TraceId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Trace ID untuk distributed tracing
/// Connector name (e.g., "http", "postgres")
func (rcv *ExecuteRequest) ConnectorName() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Connector name (e.g., "http", "postgres")
/// Operation name (e.g., "request", "query")
func (rcv *ExecuteRequest) Operation() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Operation name (e.g., "request", "query")
/// Deadline absolute timestamp (milliseconds)
func (rcv *ExecuteRequest) DeadlineAtMs() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

/// Deadline absolute timestamp (milliseconds)
func (rcv *ExecuteRequest) MutateDeadlineAtMs(n uint64) bool {
	return rcv._tab.MutateUint64Slot(16, n)
}

/// Payload data (operation-specific)
func (rcv *ExecuteRequest) Payload(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *ExecuteRequest) PayloadLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ExecuteRequest) PayloadBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Payload data (operation-specific)
func (rcv *ExecuteRequest) MutatePayload(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

/// Optional headers/metadata
func (rcv *ExecuteRequest) Headers(obj *KeyValue, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ExecuteRequest) HeadersLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Optional headers/metadata
func ExecuteRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(9)
}
func ExecuteRequestAddRequestId(builder *flatbuffers.Builder, requestId uint64) {
	builder.PrependUint64Slot(0, requestId, 0)
}
func ExecuteRequestAddTenantId(builder *flatbuffers.Builder, tenantId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(tenantId), 0)
}
func ExecuteRequestAddWorkspaceId(builder *flatbuffers.Builder, workspaceId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(workspaceId), 0)
}
func ExecuteRequestAddTraceId(builder *flatbuffers.Builder, traceId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(traceId), 0)
}
func ExecuteRequestAddConnectorName(builder *flatbuffers.Builder, connectorName flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(connectorName), 0)
}
func ExecuteRequestAddOperation(builder *flatbuffers.Builder, operation flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(operation), 0)
}
func ExecuteRequestAddDeadlineAtMs(builder *flatbuffers.Builder, deadlineAtMs uint64) {
	builder.PrependUint64Slot(6, deadlineAtMs, 0)
}
func ExecuteRequestAddPayload(builder *flatbuffers.Builder, payload flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(payload), 0)
}
func ExecuteRequestStartPayloadVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func ExecuteRequestAddHeaders(builder *flatbuffers.Builder, headers flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(headers), 0)
}
func ExecuteRequestStartHeadersVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ExecuteRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
/// Response dari connector
type ExecuteResponse struct {
	_tab flatbuffers.Table
}

func GetRootAsExecuteResponse(buf []byte, offset flatbuffers.UOffsetT) *ExecuteResponse {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ExecuteResponse{}
	x.Init(buf, n+offset)
	return x
}

func FinishExecuteResponseBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsExecuteResponse(buf []byte, offset flatbuffers.UOffsetT) *ExecuteResponse {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ExecuteResponse{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedExecuteResponseBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *ExecuteResponse) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ExecuteResponse) Table() flatbuffers.Table {
	return rcv._tab
}

/// Request ID yang sama dengan request
func (rcv *ExecuteResponse) RequestId() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

/// Request ID yang sama dengan request
func (rcv *ExecuteResponse) MutateRequestId(n uint64) bool {
	return rcv._tab.MutateUint64Slot(4, n)
}

/// Success atau error
func (rcv *ExecuteResponse) ErrorClass() ErrorClass {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return ErrorClass(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Success atau error
func (rcv *ExecuteResponse) MutateErrorClass(n ErrorClass) bool {
	return rcv._tab.MutateInt8Slot(6, int8(n))
}

/// Error message jika gagal
func (rcv *ExecuteResponse) ErrorMessage() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Error message jika gagal
/// Response payload jika sukses
func (rcv *ExecuteResponse) Payload(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *ExecuteResponse) PayloadLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ExecuteResponse) PayloadBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Response payload jika sukses
func (rcv *ExecuteResponse) MutatePayload(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

/// Execution duration (microseconds)
func (rcv *ExecuteResponse) DurationUs() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

/// Execution duration (microseconds)
func (rcv *ExecuteResponse) MutateDurationUs(n uint64) bool {
	return rcv._tab.MutateUint64Slot(12, n)
}

func ExecuteResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func ExecuteResponseAddRequestId(builder *flatbuffers.Builder, requestId uint64) {
	builder.PrependUint64Slot(0, requestId, 0)
}
func ExecuteResponseAddErrorClass(builder *flatbuffers.Builder, errorClass ErrorClass) {
	builder.PrependInt8Slot(1, int8(errorClass), 0)
}
func ExecuteResponseAddErrorMessage(builder *flatbuffers.Builder, errorMessage flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(errorMessage), 0)
}
func ExecuteResponseAddPayload(builder *flatbuffers.Builder, payload flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(payload), 0)
}
func ExecuteResponseStartPayloadVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func ExecuteResponseAddDurationUs(builder *flatbuffers.Builder, durationUs uint64) {
	builder.PrependUint64Slot(4, durationUs, 0)
}
func ExecuteResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
/// Health check response
type HealthCheckResponse struct {
	_tab flatbuffers.Table
}

func GetRootAsHealthCheckResponse(buf []byte, offset flatbuffers.UOffsetT) *HealthCheckResponse {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &HealthCheckResponse{}
	x.Init(buf, n+offset)
	return x
}

func FinishHealthCheckResponseBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsHealthCheckResponse(buf []byte, offset flatbuffers.UOffsetT) *HealthCheckResponse {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &HealthCheckResponse{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedHealthCheckResponseBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *HealthCheckResponse) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *HealthCheckResponse) Table() flatbuffers.Table {
	return rcv._tab
}

/// Is healthy
func (rcv *HealthCheckResponse) Healthy() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Is healthy
func (rcv *HealthCheckResponse) MutateHealthy(n bool) bool {
	return rcv._tab.MutateBoolSlot(4, n)
}

/// Status message
func (rcv *HealthCheckResponse) Message() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Status message
/// Current active requests
func (rcv *HealthCheckResponse) ActiveRequests() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Current active requests
func (rcv *HealthCheckResponse) MutateActiveRequests(n uint32) bool {
	return rcv._tab.MutateUint32Slot(8, n)
}

/// Available credits
func (rcv *HealthCheckResponse) AvailableCredits() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Available credits
func (rcv *HealthCheckResponse) MutateAvailableCredits(n uint32) bool {
	return rcv._tab.MutateUint32Slot(10, n)
}

func HealthCheckResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func HealthCheckResponseAddHealthy(builder *flatbuffers.Builder, healthy bool) {
	builder.PrependBoolSlot(0, healthy, false)
}
func HealthCheckResponseAddMessage(builder *flatbuffers.Builder, message flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(message), 0)
}
func HealthCheckResponseAddActiveRequests(builder *flatbuffers.Builder, activeRequests uint32) {
	builder.PrependUint32Slot(2, activeRequests, 0)
}
func HealthCheckResponseAddAvailableCredits(builder *flatbuffers.Builder, availableCredits uint32) {
	builder.PrependUint32Slot(3, availableCredits, 0)
}
func HealthCheckResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
/// Credit update untuk backpressure
type CreditUpdate struct {
	_tab flatbuffers.Table
}

func GetRootAsCreditUpdate(buf []byte, offset flatbuffers.UOffsetT) *CreditUpdate {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CreditUpdate{}
	x.Init(buf, n+offset)
	return x
}

func FinishCreditUpdateBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsCreditUpdate(buf []byte, offset flatbuffers.UOffsetT) *CreditUpdate {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CreditUpdate{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedCreditUpdateBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *CreditUpdate) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CreditUpdate) Table() flatbuffers.Table {
	return rcv._tab
}

/// Credits to add (positive) or remove (negative)
func (rcv *CreditUpdate) CreditDelta() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Credits to add (positive) or remove (negative)
func (rcv *CreditUpdate) MutateCreditDelta(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

/// Current total credits available
func (rcv *CreditUpdate) TotalCredits() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Current total credits available
func (rcv *CreditUpdate) MutateTotalCredits(n uint32) bool {
	return rcv._tab.MutateUint32Slot(6, n)
}

func CreditUpdateStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func CreditUpdateAddCreditDelta(builder *flatbuffers.Builder, creditDelta int32) {
	builder.PrependInt32Slot(0, creditDelta, 0)
}
func CreditUpdateAddTotalCredits(builder *flatbuffers.Builder, totalCredits uint32) {
	builder.PrependUint32Slot(1, totalCredits, 0)
}
func CreditUpdateEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
/// Key-value pair untuk headers/metadata
type KeyValue struct {
	_tab flatbuffers.Table
}

func GetRootAsKeyValue(buf []byte, offset flatbuffers.UOffsetT) *KeyValue {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &KeyValue{}
	x.Init(buf, n+offset)
	return x
}

func FinishKeyValueBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsKeyValue(buf []byte, offset flatbuffers.UOffsetT) *KeyValue {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &KeyValue{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedKeyValueBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *KeyValue) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *KeyValue) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *KeyValue) Key() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *KeyValue) Value() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func KeyValueStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func KeyValueAddKey(builder *flatbuffers.Builder, key flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(key), 0)
}
func KeyValueAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(value), 0)
}
func KeyValueEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
